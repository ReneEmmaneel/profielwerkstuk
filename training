import numpy as np
import cnn as cnn
import math as math
import random as random
import time as time
import os.path

print "start met trainen...."

#training functie
def train(alpha, totalGeneration, inputPerWeight, modelfile, metadatafile, inputTraining=""):
    
    #ervoor zorgen dat data goed wordt weggeschreven
    with open(metadatafile, "w") as myfile:
        myfile.write('\n\n\n\n')
    
    #tijd en generatie bijhouden
    startTime = int(time.time())
    vorigeTijd = startTime
    generation = 0
    
    vervangTekst(metadatafile, 0, "Training gestart op " + str(int(time.time())) + "..\n")

    #labels initialization
    #lettersArray = ['0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']
    lettersArray = ['0','1']
   
    AllLabels = np.zeros((len(lettersArray), len(lettersArray)))
    for x in xrange(len(lettersArray)):
        for y in xrange(len(lettersArray)):
            if x == y:
                AllLabels[x][y] = 1
    
    #initialization (moet wss veranderd worden)
    #endkernels1 = uiteindelijke resultaat
    #kernels1 = huidige test
    EndKernels1 = np.zeros((6,25))
    Kernels1 = EndKernels1
    EndKernels2 = np.zeros((6,9))
    Kernels2 = EndKernels2
    Endweights = 2 * np.random.random_sample((1296, 36)) - 1
    weights = Endweights
    
    #importen van oude training (werk ik later wel aan)
    #if len(inputTraining) > 0:
    #    print "oude trainingsdata importen."
    #    inputTraining = inputTraining.replace("\n","")
    #    splitInputTraining = inputTraining.split(',')
    #    #generation = int(splitInputTraining[1]) + 1
    #    #currValue = float(splitInputTraining[2])
    #    generation = 0
    #    EndKernels1 = np.asarray(toarray(splitInputTraining[0]))
    #    EndKernels2 = np.asarray(toarray(splitInputTraining[1]))
    #    Endweights = np.asarray(toarray(splitInputTraining[2]))...
    
    #lege arrays
    labelSet = []
    dataSet = []
    
    #importen van data
    for x in xrange(len(lettersArray)):
        y = 0
        while os.path.isfile("dataset/" + lettersArray[x] + "/img" + str(x + 1).zfill(3)  + "-" + str(y + 1).zfill(3) + ".png"):
            dataSet.append(str("dataset/" + lettersArray[x] + "/img" + str(x + 1).zfill(3)  + "-" + str(y + 1).zfill(3) + ".png"))
            labelSet.append(int(x))
            y += 1
        y = 0
        while os.path.isfile("dataset/" + lettersArray[x] + "/img" + str(x + 1).zfill(3)  + "-" + str(y + 1).zfill(5) + ".png"):
            dataSet.append(str("dataset/" + lettersArray[x] + "/img" + str(x + 1).zfill(3)  + "-" + str(y + 1).zfill(5) + ".png"))
            labelSet.append(int(x))
            y += 1
    dataSet = np.asarray(dataSet)
    
    #label koppelen aan data
    allData = []
    i = 0
    for data in dataSet:
        allData.append([data, labelSet[i]])
        i += 1
    
    print ("dataSet generated ", str(float(time.time()) - float(startTime)) + ".")
    
    #start van nieuwe generatie
    for numLoop in xrange(totalGeneration):
        amountGen = numLoop + generation
        vervangTekst(metadatafile, 1, "Bezig met generatie " + str(amountGen) + "..\n")
        
        #genereer een random set met weights met distance = 10 tegenover de end arrays
        #als endkernels van grote verandert: ook dit veranderen
        n = len(EndKernels1) * len(EndKernels1[0]) + len(EndKernels2) * len(EndKernels2[0]) + len(Endweights) * len(Endweights[0])
        length = math.sqrt(float(10) / n)
        for x in xrange(len(Kernels1)):
            for y in xrange(len(Kernels1[x])):
                Kernels1[x][y] = EndKernels1[x][y] + 2 * length * math.floor(random.random() - 0.5) + length
                    
        for x in xrange(len(Kernels2)):
            for y in xrange(len(Kernels2[x])):
                Kernels2[x][y] = EndKernels2[x][y] + 2 * length * math.floor(random.random() - 0.5) + length
            
        for x in xrange(len(weights)):
            for y in xrange(len(weights[x])):
                weights[x][y] = Endweights[x][y] + 2 * length * math.floor(random.random() - 0.5) + length
        
        
        #print ("genereren weights", time.time() - startTime)
        
        #subdataset genereren
        gebruikteData = willekeurigeData(allData, inputPerWeight)
        
        #value berekenen
        print ('value berekenen', str(float(time.time()) - float(startTime))+ ".")
        currValueArray = np.zeros(len(gebruikteData))
        for i in xrange(len(gebruikteData)):
            """if i%40 == 0:
                print ("starten input ", i, time.time() - startTime)"""
            currValueArray[i] = cnn.cnn(Kernels1, Kernels2, weights, AllLabels[gebruikteData[i][1]], gebruikteData[i][0], startTime, False)
        total = np.average(currValueArray)
        
        #dtotal / dweight = dtotal / dout * dout / dnet * dnet / dweight
        
        
        
        
        
        
        
        
            
        """bekijk welke weights en bias het beste is"""
        sortedLoss = np.sort(allTrainingLoss)
        deltaTijd = time.time() - vorigeTijd
        vorigeTijd = time.time()
        with open(metadatafile, "a") as myfile:
            myfile.write("Generatie " + str(amountGen) + ' heeft een avarage loss van ' + str(np.average(allTrainingLoss)) + ', daar heeft het programma ' + str(deltaTijd) + ' seconden over gerekend..\n')
        
        lowestValue = 1000000
        lowestElement = 0
        for x in xrange(len(allTrainingLoss)):
            if allTrainingLoss[x] < lowestValue:
                lowestValue = allTrainingLoss[x]
                lowestElement = x
        vectorK1 = np.subtract(Kernels1[lowestElement], EndKernels1)
        vectorK2 = np.subtract(Kernels2[lowestElement], EndKernels2)
        vectorW = np.subtract(weights[lowestElement], Endweights)
        
        
        oldValue = currValue
        currValue = allTrainingLoss[lowestElement]
        
        afgeleide = currValue - oldValue #liefst is dit negatief
        
        EndKernels1 = EndKernels1 - [afgeleide * alpha * x for x in vectorK1]
        EndKernels2 = EndKernels2 - [afgeleide * alpha * x for x in vectorK2]
        Endweights = Endweights - [afgeleide * alpha * x for x in vectorW]
        #print EndKernels1, EndKernels2, Endweights
        
        
        with open(modelfile, "w") as myfile:
            myfile.write(np.array_str(EndKernels1) + ',\n')
            myfile.write(np.array_str(EndKernels2) + ',\n')
            myfile.write(np.array_str(Endweights) + ',\n')
    
    print EndKernels1, EndKernels2, Endweights

def toString(string):
    return np.asarray(string)

def willekeurigeData( data, K ):
    result = []
    N = 0
    for item in data:
        N += 1
        if len( result ) < K:
            result.append( item )
        else:
            s = int(random.random() * N)
            if s < K:
                result[s] = item
    return result
#resovoir sampling, dit wordt gebruikt om een bepaalde subset aan data te gebruiken

def toarray(string):
    a = string.split('[')
    number = []
    for i in a[2:]:
        i = i.replace("]","")
        number.append(i.split())
    number = [[float(x) for x in line] for line in number ]
    return number

def vervangTekst(file, line, text):
    lines = open(file, 'r').readlines()
    lines[line] = text
    out = open(file, 'w')
    out.writelines(lines)
    out.close()
